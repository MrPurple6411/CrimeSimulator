name: Build and Release Mods

on:
  push:
    branches: [ main, develop ]
    tags:
      - 'v*'          # Global releases (v1.2.3)
      - '*-v*'         # Individual mod releases (ModName-v1.2.3)
  pull_request:
    branches: [ main ]

permissions:
  contents: write
  packages: read

env:
  DOTNET_VERSION: '8.0.x'
  SOLUTION_FILE: 'CrimeSimulator.sln'

jobs:
  # Detect which mods to build based on changes and tag type
  detect-changes:
    name: Detect Changed Mods
    runs-on: ubuntu-latest
    outputs:
      changed-mods: ${{ steps.changes.outputs.mods }}
      tag-type: ${{ steps.tag-info.outputs.type }}
      target-mod: ${{ steps.tag-info.outputs.mod }}
      version: ${{ steps.tag-info.outputs.version }}
      should-release: ${{ steps.tag-info.outputs.should-release }}
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Analyze Git Tag
      id: tag-info
      run: |
        if [[ "${{ github.ref_type }}" == "tag" ]]; then
          TAG_NAME="${{ github.ref_name }}"
          echo "Processing tag: $TAG_NAME"
          
          if [[ $TAG_NAME =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            # Global release: v1.2.3
            echo "type=global" >> $GITHUB_OUTPUT
            echo "version=${TAG_NAME#v}" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
          elif [[ $TAG_NAME =~ ^(.+)-v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            # Individual mod: ModName-v1.2.3
            MOD_NAME="${BASH_REMATCH[1]}"
            VERSION="${BASH_REMATCH[2]}"
            echo "type=individual" >> $GITHUB_OUTPUT
            echo "mod=$MOD_NAME" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
          else
            echo "Invalid tag format: $TAG_NAME" >&2
            exit 1
          fi
        else
          echo "type=none" >> $GITHUB_OUTPUT
          echo "should-release=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Detect Changed Mods
      id: changes
      run: |
        if [[ "${{ steps.tag-info.outputs.type }}" == "global" ]]; then
          # Global tag: find all mods changed since last global tag
          LAST_GLOBAL_TAG=$(git describe --tags --abbrev=0 --match="v*" HEAD^ 2>/dev/null || echo "")
          if [[ -n "$LAST_GLOBAL_TAG" ]]; then
            CHANGED_FILES=$(git diff --name-only "$LAST_GLOBAL_TAG"..HEAD)
          else
            CHANGED_FILES=$(git diff --name-only HEAD~10..HEAD)  # fallback
          fi
        elif [[ "${{ steps.tag-info.outputs.type }}" == "individual" ]]; then
          # Individual tag: only build the specified mod
          echo "mods=${{ steps.tag-info.outputs.mod }}" >> $GITHUB_OUTPUT
          exit 0
        else
          # Regular commit: find changed files since last commit
          CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD)
        fi
        
        # Extract mod names from changed files in src/
        MODS=$(echo "$CHANGED_FILES" | grep "^src/" | cut -d'/' -f2 | sort -u | tr '\n' ' ' | sed 's/[[:space:]]*$//')
        echo "Changed mods: $MODS"
        echo "mods=$MODS" >> $GITHUB_OUTPUT

  # Build the detected mods
  build:
    name: Build Mods
    runs-on: windows-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.changed-mods != ''
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Update Plugin Version to Match Tag
      if: needs.detect-changes.outputs.tag-type == 'individual'
      run: |
        $modName = "${{ needs.detect-changes.outputs.target-mod }}"
        $newVersion = "${{ needs.detect-changes.outputs.version }}"
        $projectPath = "src\$modName\$modName.csproj"
        
        if (Test-Path $projectPath) {
          Write-Output "Validating and updating $projectPath to version $newVersion"
          
          # Switch to main branch first to get current version
          git checkout main
          
          # Read the project file from main branch
          $content = Get-Content $projectPath -Raw
          
          # Extract current PluginVersion
          if ($content -match '<PluginVersion>(.*?)</PluginVersion>') {
            $currentVersion = $matches[1]
            Write-Output "Current version: $currentVersion"
            Write-Output "New version: $newVersion"
            
            # Parse versions for comparison
            $current = [Version]$currentVersion
            $new = [Version]$newVersion
            
            if ($new -lt $current) {
              Write-Error "New version $newVersion is less than current version $currentVersion. Tag version must be greater than or equal to current version."
              exit 1
            } elseif ($new -eq $current) {
              Write-Output "Version $newVersion matches current version - checking for existing release..."
              
              # Check if a release already exists for this version
              $releaseTag = "$modName-v$newVersion"
              Write-Output "Checking for existing release: $releaseTag"
              
              try {
                $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/tags/$releaseTag" -Headers @{
                  "Authorization" = "Bearer ${{ secrets.GITHUB_TOKEN }}"
                  "Accept" = "application/vnd.github.v3+json"
                } -ErrorAction Stop
                
                Write-Error "Release $releaseTag already exists (ID: $($response.id)). Cannot create duplicate release for the same version."
                exit 1
              } catch {
                if ($_.Exception.Response.StatusCode -eq 404) {
                  Write-Output "SUCCESS: No existing release found for $releaseTag - proceeding with build"
                } else {
                  Write-Error "Failed to check for existing release: $($_.Exception.Message)"
                  exit 1
                }
              }
            } else {
              Write-Output "Version $newVersion is greater than current version $currentVersion - updating..."
              
              # Update the PluginVersion property
              $pattern = '<PluginVersion>.*?</PluginVersion>'
              $replacement = "<PluginVersion>$newVersion</PluginVersion>"
              $updatedContent = $content -replace $pattern, $replacement
              
              # Write back to file
              Set-Content -Path $projectPath -Value $updatedContent -NoNewline
              
              Write-Output "SUCCESS: Updated PluginVersion to $newVersion in $projectPath"
              
              # Commit the version update (already on main branch)
              git config --local user.email "action@github.com"
              git config --local user.name "GitHub Action"
              git add $projectPath
              git commit -m "Auto-update $modName version to $newVersion from release tag [skip ci]"
              git push origin main
              Write-Output "SUCCESS: Committed version update to repository"
            }
          } else {
            Write-Warning "Could not find PluginVersion in $projectPath"
          }
        } else {
          Write-Warning "Project file not found: $projectPath"
        }
      shell: pwsh
        
    - name: Restore Dependencies
      run: dotnet restore ${{ env.SOLUTION_FILE }}
      
    - name: Build Changed Mods
      run: |
        $changedMods = "${{ needs.detect-changes.outputs.changed-mods }}"
        $version = "${{ needs.detect-changes.outputs.version }}"
        $tagType = "${{ needs.detect-changes.outputs.tag-type }}"
        
        if ([string]::IsNullOrEmpty($changedMods)) {
          Write-Output "No mods to build"
          exit 0
        }
        
        $mods = $changedMods -split '\s+' | Where-Object { $_ -ne '' }
        Write-Output "Building mods: $($mods -join ', ')"
        
        # Create output directory
        New-Item -ItemType Directory -Force -Path "release-packages"
        
        foreach ($modName in $mods) {
          Write-Output "Processing mod: $modName"
          
          $projectPath = "src\$modName\$modName.csproj"
          
          if (Test-Path $projectPath) {
            Write-Output "Building and packaging mod: $modName"
            
            # Build and package using our Directory.Build.targets
            dotnet build $projectPath --configuration Release --no-restore -p:CreatePackage=true
            
            # Find the generated package
            $packagePath = "src\$modName\bin\Release\Package"
            if (Test-Path $packagePath) {
              $zipFile = Get-ChildItem "$packagePath\*.zip" | Select-Object -First 1
              if ($zipFile) {
                # Determine final filename based on tag type
                if ($tagType -eq "individual" -and "${{ needs.detect-changes.outputs.target-mod }}" -eq $modName) {
                  $finalFileName = "$modName-v$version.zip"
                } elseif ($tagType -eq "global") {
                  $finalFileName = "$modName-v$version.zip"
                } else {
                  $finalFileName = "$modName-dev.zip"
                }
                
                $finalPath = "release-packages\$finalFileName"
                Copy-Item $zipFile.FullName $finalPath
                Write-Output "Created package: $finalPath"
              } else {
                Write-Error "No zip file found in package directory: $packagePath"
                exit 1
              }
            } else {
              Write-Error "Package directory not found: $packagePath"
              exit 1
            }
          } else {
            Write-Warning "Project file not found: $projectPath"
          }
        }
      shell: pwsh
      
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: mod-packages-${{ github.sha }}
        path: release-packages/
        retention-days: 30

  # Create releases for tagged builds
  release:
    name: Create Releases
    runs-on: ubuntu-latest
    needs: [detect-changes, build]
    if: needs.detect-changes.outputs.should-release == 'true'
    
    steps:
    - name: Download Build Artifacts
      uses: actions/download-artifact@v4
      with:
        name: mod-packages-${{ github.sha }}
        path: release-packages/
        
    - name: Create Individual Mod Release
      if: needs.detect-changes.outputs.tag-type == 'individual'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.ref_name }}
        name: "${{ needs.detect-changes.outputs.target-mod }} v${{ needs.detect-changes.outputs.version }}"
        body: |
          ## ${{ needs.detect-changes.outputs.target-mod }} v${{ needs.detect-changes.outputs.version }}
          
          Individual mod release for **${{ needs.detect-changes.outputs.target-mod }}**.
          
          ### Installation
          1. Download the ZIP file below
          2. Extract to your game directory
          3. Run the game once to initialize BepInEx
        files: |
          release-packages/${{ needs.detect-changes.outputs.target-mod }}-v${{ needs.detect-changes.outputs.version }}.zip
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Create Global Release
      if: needs.detect-changes.outputs.tag-type == 'global'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.ref_name }}
        name: "Crime Simulator Mods v${{ needs.detect-changes.outputs.version }}"
        body: |
          ## Crime Simulator Mods v${{ needs.detect-changes.outputs.version }}
          
          Multi-mod release containing updates for:
          ${{ needs.detect-changes.outputs.changed-mods }}
          
          ### Installation
          1. Download the mod ZIP files you want below
          2. Extract each to your game directory
          3. Run the game once to initialize BepInEx
        files: |
          release-packages/*.zip
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}